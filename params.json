{"name":"Monk-C","tagline":"Monk-C is a toolkit for OOP in pure C","body":"# Monk-C\r\na toolkit for OOP programming in C language\r\n[more detail at github](https://github.com/sunpaq/monkc/)\r\n\r\n![Mou icon](https://secure.gravatar.com/avatar/63f7c4c0a269ebaf049724a024bf01b4?s=420&d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png)\r\n\r\n## Overview\r\n\r\n**Monk-C**, is a toolkit for OOP programming use pure C. the aim of Monk-C is to support OOP in pure C with some tiny C macros, functions and even a light preprocessor. Monk-C is inspired by Apple Objective-C and gcc builtin \"Constructing Calls\". It is tiny and primitive but full of fun. I use it to play with my RaspberryPi and it really vary suitable for the ARM/Linux based embeded systems. It is open source under BSD license(3-clause license). I written it under the X86/Linux platform and X86/MacOS ARM/Linux is also fully tested and supportted both 32bit and 64bit.\r\n\r\n#### supported platforms:\r\n\r\n\t[CPUArch/OS/Compiler]\r\n\r\n\tIA-32/Linux/gcc&clang    OK\r\n\tX86-64/Linux/gcc&clang \t No Test\r\n\tIA-32/MacOS/gcc&clang \t No Test\r\n\tX86-64/MacOS/gcc&clang   OK\r\n\tARM32/Linux/gcc&clang    OK (RaspberryPi/Linux)\r\n\tARM64/Linux/gcc&clang    No Test\r\n\r\n#### need these tools:\r\n\tclang - I strongly recommand use this C compiler. because i found it can report more detailed error infomations\r\n\tflex - this is needed to build the 'mcpp' preprocessor for monkc\r\n\r\n#### recomand code editor:\r\n\tSublime Text \r\n\t(you can use any editor. but some one have auto-complete function will help a lot)\r\n\r\n#### easy way for Mac users (Xcode/intel x86_64):\r\n\r\n###### Build a simple command line tool use MonkC:\r\n\tjust use the Xcode project templete in /XcodeMonkC/MonkCAppTemplete/\r\n\t\r\n###### Hack the monkc runtime system for your unique requirement:\r\n\tjust check the Xcode project templete in /XcodeMonkC/MonkCRuntimeStaticLib/\r\n\r\n#### how to compile and install (command line):\r\n\r\n\t0. default is compile by 'clang'. make sure you have one installed. \r\n\t   it also need 'flex'. you can install flex by 'sudo apt-get install flex' on Ubuntu\r\n\t   or install flex use macport on Mac OS X\r\n\t1. cd ./src\r\n\t2. sudo make install\r\n\r\n\tclang is recommand. cause it can output better error infomations\r\n\tif you want change it to gcc\r\n\tchange [ CC = clang -> CC = gcc ] in:\r\n\t1. /src/monkc_runtime/Makefile \t    -> line10 \r\n\t2. /src/monkc_buildtool/mcbuild     -> line12\r\n\t3. /src/lemontea/Makefile\t\t\t-> line9\r\n\t4. /src/tests/Makefile\t\t\t\t-> line7\r\n\tto use gcc as the compiler\r\n\r\n\tthe command above will build the <libmonkc.a> <liblemontea.a>\r\n\tand automatically copy them to \t\t\t\t/usr/local/lib/\r\n\tand copy the <.h> header files to \t\t\t/usr/local/include/\r\n\tand copy the <mcpp> <mcbuild> tool to \t\t/usr/local/bin/\r\n\r\n#### how to create and build a monkc project:\r\n\r\n\t1. mkdir <your project dir>\r\n\t2. cd <your project dir> && mcbuild -create\r\n\t3. write code in the <your project dir/src> folder\r\n\t  (you can use any folder structure to organize your code)\r\n\t4. cd <your project dir> && mcbuild -build\r\n\t5. the output binary will be 'exec' in the project root dir\r\n\t  (see the examples folder for more details)\r\n\r\n## Syntax\r\n**Monk-C** use \"MC\" as the prefix.\r\n#### main entry\r\n\r\n\tmake sure you called all the code written by monkc\r\n\tbetween mc_init() and mc_end()\r\n\tit is better to put the mc_init() at the very beginning of main()\r\n\tand to put the mc_end() at the end of main()\r\n\r\n\tint main(int argc, char const *argv[])\r\n\t{\r\n\t\tmc_init();\r\n\t\t\tLOG_LEVEL = MC_VERBOSE;\r\n\t\t\ttest_object_life_cycle();\r\n\t\tmc_end();\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tglobal log level:\r\n\tyou can set the global variable LOG_LEVEL to:\r\n\tMC_SILENT\t\t//no log outputed\r\n\tMC_ERROR_ONLY  //error log only\r\n\tMC_DEBUG \t\t//error log and debug log\r\n\tMC_VERBOSE     //error log and debug log and runtime log\r\n\r\n\tyou can use:\r\n\terror_log()\r\n\tdebug_log()\r\n\truntime_log()\r\n\tto output logs. parameter is same as printf(char* fmt, ...)\r\n\r\n#### declear interface - write in .h file\r\n\r\n\t#include \"monkc.h\" ---> must include\r\n\t#include \"BirdFather.h\"\t ---> super class\r\n\r\n\t#ifndef Bird_ ---> avoid multi-defines\r\n\t#define Bird_\r\n\r\n\timplements(Flyable); ---> protocol mark\r\n\textends(BirdFather); ---> super class mark\r\n\r\n\tmonkc(Bird); ---> class data begin\r\n\t\tchar* name;\r\n\t\tint type;\r\n\tend(Bird); ---> class data end\r\n\r\n\tmethod(Bird, void, bye, xxx); ---> class public method list begin\r\n\tmethod(Bird, Bird*, initWithType, int type);\r\n\tmethod(Bird, void, fly, xxx);\r\n\tmethod(Bird, int, fatherAge, xxx); ---> class public method list end\r\n\r\n\t#endif ---> avoid multi-defines\r\n\t\r\n#### implement methods - write in .c file\r\n\t\t\r\n\t#include \"Bird.h\"\r\n\r\n\tiniter(Bird) ---> must have. initialize the class data\r\n\t{\r\n\t\tthis->super = new(BirdFather); ---> new your super by hand!\r\n\t\tthis->type = 3;\r\n\t\tdebug_logt(\"Bird\", \"[%p] init called\\n\", this);\r\n\t}\r\n\r\n\tmethod(Bird, void, bye, xxx) ---> 1.public method implements\r\n\t{\r\n\t\tdebug_logt(nameof(this), \"[%p] bye called\\n\", this);\r\n\t\trecycle(this->super);\r\n\t}\r\n\r\n\tstatic void funcA(Bird* this, int arg1) ---> 2.private C function\r\n\t{\r\n\t\tdebug_log(\"i am local function A\\n\");\r\n\t}\r\n\r\n\tprotocol(Flyable, void, duckFly, xxx) ---> 3.protocol method you comply with\r\n\t{\r\n\t\tdebug_log(\"%s\\n\", \"Bird:Duck GuaGuaGua fly\");\r\n\t}\r\n\r\n\tprotocol(Flyable, void, chickenFly, xxx)\t\t\r\n\t{\r\n\t\tdebug_log(\"%s\\n\", \"Bird:Chicken JiJiJi fly\");\r\n\t}\r\n\r\n\tmethod(Bird, Bird*, initWithType, int type)\r\n\t{\r\n\t\tthis->type = type;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tmethod(Bird, int, fatherAge, xxx)\r\n\t{\r\n\t\tint fage = cast(BirdFather, this->super)->age;\r\n\t\tdebug_logt(nameof(this), \"my father age is: %d\\n\", fage);\r\n\t\treturn fage;\r\n\t}\r\n\r\n\tmethod(Bird, void, fly, xxx)\r\n\t{\r\n\t\tdebug_log(\"Bird[%p->%p]: default fly type %d\\n\", this, this->super, this->type);\r\n\t\tfuncA(this, 100);\r\n\t}\r\n\r\n\tloader(Bird) ---> must have. binding methods at runtime.\r\n\t{\r\n\t\tdebug_logt(nameofc(class), \"load called\\n\");\r\n\t\t#include \"Flyable.p\"\r\n\r\n\t\tbinding(Bird, Bird*, initWithType, int type);\r\n\t\tbinding(Bird, void, bye, xxx);\r\n\t\tbinding(Bird, void, fly, xxx);\r\n\t\tbinding(Bird, int, fatherAge, xxx);\r\n\t}\r\n\r\n####method calling\r\n\r\n\tit just like the Objective-C. sending message instead of function call.\r\n\r\n\tBird* bird = new(Bird);\r\n\tff(bird, fly, nil);\r\n\r\n####Macros and runtime functions\r\n\r\n---\r\n\r\n1. monkc\r\n2. end\r\n3. initer\r\n4. loader\r\n5. method\r\n6. protocol\r\n7. binding\r\n8. override\r\n9. new\r\n10. call\r\n11. ff\r\n12. retain\r\n13. release\r\n14. recycle\r\n15. shift\r\n16. shift_back\r\n17. this\r\n18. cast\r\n19. nameof\r\n20. nameofc\r\n\r\n---\r\n\r\nTotal **20** words.[^1]\r\n\r\n####protocol file\r\n\r\n\t<Flyable.p>\r\n\r\n\tbinding(Flyable, void, duckFly, xxx);\r\n\tbinding(Flyable, void, chickenFly, xxx);\r\n\r\n\r\n######the BIND part (include in .c file):\r\n\r\n\tloader(Bird)\r\n\t{\r\n\t\tdebug_logt(class->name, \"load called\\n\");\r\n\t\t#include \"Flyable.p\"\r\n\r\n\t\tbinding(Bird, Bird*, initWithType, int type);\r\n\t\tbinding(Bird, void, bye, xxx);\r\n\t\tbinding(Bird, void, fly, xxx);\r\n\t\tbinding(Bird, int, fatherAge, xxx);\r\n\t}\r\n\r\n\r\n####TODO list:\r\n\r\n\t1. add type convert to preprocessor mcpp\r\n\r\n\t2. add auto binding to preprocessor mcpp\r\n\r\n\t3. add arg type check to preprocessor mcpp\r\n\r\n\t4. lemontea_WEB\r\n\r\n\t5. lemontea_GUI\r\n\r\n\t6. lemontea_3D\r\n\r\n[^1]: the syntex is improving, maybe more/less keywords in the feature.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}